"""Module for collecting lowest energy structure."""

import gzip
import re
from collections import deque

import rdkit.Chem.AllChem as rdkit  # noqa: N813
from rdkit.Geometry import Point3D

bond_dict = {
    "1": rdkit.rdchem.BondType.SINGLE,
    "am": rdkit.rdchem.BondType.SINGLE,
    "2": rdkit.rdchem.BondType.DOUBLE,
    "3": rdkit.rdchem.BondType.TRIPLE,
    "ar": rdkit.rdchem.BondType.AROMATIC,
}

periodic_table = {
    1: "H",
    2: "He",
    3: "Li",
    4: "Be",
    5: "B",
    6: "C",
    7: "N",
    8: "O",
    9: "F",
    10: "Ne",
    11: "Na",
    12: "Mg",
    13: "Al",
    14: "Si",
    15: "P",
    16: "S",
    17: "Cl",
    18: "Ar",
    19: "K",
    20: "Ca",
    21: "Sc",
    22: "Ti",
    23: "V",
    24: "Cr",
    25: "Mn",
    26: "Fe",
    27: "Co",
    28: "Ni",
    29: "Cu",
    30: "Zn",
    31: "Ga",
    32: "Ge",
    33: "As",
    34: "Se",
    35: "Br",
    36: "Kr",
    37: "Rb",
    38: "Sr",
    39: "Y",
    40: "Zr",
    41: "Nb",
    42: "Mo",
    43: "Tc",
    44: "Ru",
    45: "Rh",
    46: "Pd",
    47: "Ag",
    48: "Cd",
    49: "In",
    50: "Sn",
    51: "Sb",
    52: "Te",
    53: "I",
    54: "Xe",
    55: "Cs",
    56: "Ba",
    57: "La",
    58: "Ce",
    59: "Pr",
    60: "Nd",
    61: "Pm",
    62: "Sm",
    63: "Eu",
    64: "Gd",
    65: "Tb",
    66: "Dy",
    67: "Ho",
    68: "Er",
    69: "Tm",
    70: "Yb",
    71: "Lu",
    72: "Hf",
    73: "Ta",
    74: "W",
    75: "Re",
    76: "Os",
    77: "Ir",
    78: "Pt",
    79: "Au",
    80: "Hg",
    81: "Tl",
    82: "Pb",
    83: "Bi",
    84: "Po",
    85: "At",
    86: "Rn",
    87: "Fr",
    88: "Ra",
    89: "Ac",
    90: "Th",
    91: "Pa",
    92: "U",
    93: "Np",
    94: "Pu",
    95: "Am",
    96: "Cm",
    97: "Bk",
    98: "Cf",
    99: "Es",
    100: "Fm",
    101: "Md",
    102: "No",
    103: "Lr",
    104: "Rf",
    105: "Db",
    106: "Sg",
    107: "Bh",
    108: "Hs",
    109: "Mt",
    110: "Ds",
    111: "Rg",
    112: "Cn",
    113: "Uut",
    114: "Fl",
    115: "Uup",
    116: "Lv",
    117: "Uus",
    118: "Uuo",
}


def convert_maegz_to_mae(Cagename, destination_folder_end, name):
    """Convert a ``.maegz`` file to a ``.mae`` file.

    Parameters
    ----------
    run_name : :class:`str`
        The name of the run. The files generated by this run will
        have this name.

    Returns
    -------
    None : :class:`NoneType`

    """
    run_name = f"{destination_folder_end}/{Cagename}/{name}"

    gz_file = gzip.open(f"{run_name}")
    with open(f"{run_name}.mae", "wb") as f:
        f.write(gz_file.read())
    gz_file.close()


def mol_from_mae_file(Cagename, destination_folder_end, mae_end):
    """Creates a ``rdkit`` molecule from a ``.mae`` file.

    Parameters
    ----------
    mol2_file : :class:`str`
        The full path of the ``.mae`` file from which an rdkit molecule
        should be instantiated.

    Returns
    -------
    :class:`rdkit.Mol`
        An ``rdkit`` instance of the molecule held in `mae_file`.

    """
    mae_path = f"{destination_folder_end}/{Cagename}/{mae_end}"
    mols = {}  # List to store all the molecule structures

    # mol = rdkit.EditableMol(rdkit.Mol())
    # conf = rdkit.Conformer()

    with open(mae_path) as mae:
        content = re.split(r"[{}]", mae.read())
    prev_block = deque([""], maxlen=1)
    atom_blocks = []
    bond_blocks = []
    structure_names = []
    for block in content:
        if "m_atom[" in prev_block[0]:
            atom_blocks.append(block)
        if "m_bond[" in prev_block[0]:
            bond_blocks.append(block)
        if "f_m_ct " in prev_block[0]:
            lines = block.split("\n")
            for line in lines:
                if line.startswith("  Cage_"):
                    structure_name = line.strip()
                    structure_names.append(structure_name)
                    break
        prev_block.append(block)
    # print(structure_names)
    # print(len(atom_blocks),len(bond_blocks),len(structure_names))
    for atom_block, bond_block, structure_name in zip(
        atom_blocks, bond_blocks, structure_names, strict=False
    ):
        mol = rdkit.EditableMol(rdkit.Mol())
        conf = rdkit.Conformer()
        labels, data_block, *_ = atom_block.split(":::")
        labels = [
            label
            for label in labels.split("\n")
            if not label.isspace() and label != ""
        ]

        data_block = [
            a.split()
            for a in data_block.split("\n")
            if not a.isspace() and a != ""
        ]

        for line in data_block:
            line = [word for word in line if word != '"']
            if len(labels) != len(line):
                raise RuntimeError(
                    "Number of labels does"
                    " not match number of columns"
                    " in .mae file."
                )

            for label, data in zip(labels, line, strict=False):
                if "x_coord" in label:
                    x = float(data)
                if "y_coord" in label:
                    y = float(data)
                if "z_coord" in label:
                    z = float(data)
                if "atomic_number" in label:
                    atom_num = int(data)

            atom_sym = periodic_table[atom_num]
            atom_coord = Point3D(x, y, z)
            atom_id = mol.AddAtom(rdkit.Atom(atom_sym))
            conf.SetAtomPosition(atom_id, atom_coord)

        labels, data_block, *_ = bond_block.split(":::")
        labels = [
            label
            for label in labels.split("\n")
            if not label.isspace() and label != ""
        ]
        data_block = [
            a.split()
            for a in data_block.split("\n")
            if not a.isspace() and a != ""
        ]

        for line in data_block:
            if len(labels) != len(line):
                raise RuntimeError(
                    "Number of labels does"
                    " not match number of "
                    "columns in .mae file."
                )

            for label, data in zip(labels, line, strict=False):
                if "from" in label:
                    atom1 = int(data) - 1
                if "to" in label:
                    atom2 = int(data) - 1
                if "order" in label:
                    bond_order = str(int(data))
            mol.AddBond(atom1, atom2, bond_dict[bond_order])

        mol = mol.GetMol()
        mol.AddConformer(conf)
        mols[structure_name] = mol  # Storing the mol with its name as key
    return mols


def log_to_mol(
    Cagename, destination_folder_end, log_file="no_constraints.log"
):
    destination_folder = f"{destination_folder_end}/{Cagename}"

    minima_for_file = []
    temp_energy = None
    minima_for_file = []
    structure_names = []
    output_filename = f"{destination_folder}/energies.txt"

    with open(f"{destination_folder}/{log_file}") as f:
        file_content = f.read()
        structure_name_matches = re.findall(
            r"Structure name, if any, appears on next line:\s*(.*?)\s",
            file_content,
        )
        if structure_name_matches:
            structure_names = structure_name_matches

    energy_counter = 0  # Counter to track every second 'Total Energy'

    with (
        open(output_filename, "w+") as input1,
        open(f"{destination_folder}/{log_file}") as f,
    ):
        lines = f.readlines()
        structure_index = 0  # To keep track of which structure name to use

        for line in lines:
            if "Total Energy" in line:
                energy_counter += 1
                if (
                    energy_counter % 2 == 0
                ):  # Process only every second 'Total Energy'
                    word = re.findall("\\d*\\.?\\d+", line)
                    if word:
                        current_energy = float(word[0])
                        if temp_energy is None or current_energy < temp_energy:
                            temp_energy = current_energy

            elif (
                "_" in line
                and "WARNING" not in line
                and temp_energy is not None
            ):
                structure_name = (
                    structure_names[structure_index]
                    if structure_index < len(structure_names)
                    else "Unknown"
                )
                structure_index += 1
                minima_for_file.append((temp_energy, structure_name))
                temp_energy = None  # Reset temp_energy for the next iteration
                energy_counter = (
                    0  # Reset energy counter for the next set of energy values
                )

        # with open(output_filename, "w+") as input1, open(f'{destination_folder}/{log_file}', 'r') as f:
        #    lines = f.readlines()
        #    structure_index = 0  # To keep track of which structure name to use
        #    for line in lines:  # Looping through lines from bottom to top
        #        if 'Total Energy' in line:
        #            word = re.findall('\\d*\\.?\\d+', line)
        #            if word:
        #                current_energy = float(word[0])
        #                if temp_energy is None or current_energy < temp_energy:
        #                    temp_energy = current_energy
        #        elif '_' in line and 'WARNING' not in line and temp_energy is not None:
        #            structure_name = structure_names[structure_index] if structure_index < len(structure_names) else "Unknown"
        #            structure_index += 1
        #            minima_for_file.append((temp_energy, structure_name))
        #            temp_energy = None  # Reset temp_energy for the next iteration
        #
        for element in sorted(minima_for_file):
            input1.write(str(element) + "\n")
        #
        if minima_for_file:
            min_energy = min(x[0] for x in minima_for_file)
            filtered_minima = [
                (energy, name)
                for energy, name in sorted(minima_for_file)
                if energy <= min_energy + 50
            ]

    filtered_names = set(name for energy, name in filtered_minima)
    return filtered_names


def write_out_mol(Cagename, destination_folder_end, mols_dict, filtered_names):
    destination_folder = f"{destination_folder_end}/{Cagename}"

    iter = 0
    for name, mol in mols_dict.items():
        if name in filtered_names:
            iter = iter + 1
            with open(f"{destination_folder}/{name}.mol", "w+") as f:
                print(rdkit.MolToMolBlock(mol), file=f)
    return iter
